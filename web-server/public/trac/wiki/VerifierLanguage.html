
<html><head><link rel="stylesheet" href="trac.css" type="text/css" />
</head><body>

<p>
edited by derrley on Friday September 21, 2007 to reflect the newest state of the art. 
</p>
<h1 id="S-expressions">S-expressions</h1>
<p>
We express our language using s-expression constructs. The S-expression is a syntactic form used to express the semantic concept of nested tuples.
</p>
<p>
Here we give a recursive definition of s-expressions:
</p>
<ul><li>An s-expression is:
<ul><li><em>base case</em>: an atomic string of bytes
</li><li><em>generative case</em>: a collection of expressions, prefixed by '(', postfixed by ')', and dileneated by ' '. 
<ul><li>If list L is generated by expressions E1, E2, and E3 in the form (E1 E2 E3), E1, E2, and E3 are said to be <em>direct subexpressions</em> of L.
</li></ul></li></ul></li></ul><p>
Example s-expressions:
</p>
<ul><li><strong>kyle</strong>
</li><li><strong>(kyle)</strong> (1 direct subexpression: kyle)
</li><li><strong>(kyle is cool)</strong> (3 direct subexpressions: {kyle, is, cool})
</li><li><strong>((kyle) (is) (cool))</strong> ( 3 direct subexpressions: {(kyle), (is), (cool)}, 6 total subexpressions: {(kyle), (is), (cool), kyle, is, cool})
</li><li><strong>((kyle is cool))</strong> ( 1 direct subexpression: {(kyle is cool)}, 4 total subexpressions: {(kyle is cool), kyle, is, cool})
</li></ul><h2 id="SpecialExpressions">Special Expressions</h2>
<p>
We also explicitly define a finite number of "special" expressions. Special expressions are all, by coincidence, prefixed by the '#' character, but any expression which is not a member of the following set is simply a string whose first character is '#,' and not a special expression.
</p>
<ul><li><em>#any</em>
</li><li><em>#string</em> 
</li><li><em>#list:E</em> (where E is an expression) 
</li><li><em>#wildcard</em>
</li><li><em>#nothing</em>
</li><li><em>#nomatch</em>
</li></ul><h2 id="NamedExpressions">Named Expressions</h2>
<p>
Any expression can also be assigned any string as its "name.":
</p>
<ul><li><em>%S:E</em> is the expression E named by the string S. 
</li></ul><h2 id="Match">Match</h2>
<p>
For any two expressions P (pattern) and T (target), P matches T if:
</p>
<ul><li>P and T are equivalent strings
</li><li>P is #any
</li><li>P is #string and T is any string
</li><li>P is #wildcard, E is any expression, and T is one of {#any, #string, #wildcard, #list:E}.
</li><li>P,T are lists of the same length and every direct subexpression in P matches every corresponding direct subexpression in T.
</li><li>E is any expression, P is #list:E, T is a list, and E matches each direct subexpression in T.
</li></ul><p>
Otherwise, P does not match T. 
</p>
<p>
We use this conceptual notion of "match" to define the operation match: expression X expression --&gt; expression:
</p>
<p>
match(P, T) =
</p>
<ul><li>#nomatch, if P does not match T
</li><li>L, such that L is a list, and if L is not empty:
<ul><li>the direct subexpressions of L are subexpressions of T
</li><li>Each subexpression in P that is also a special, wildcard expression matches a unique direct subexpression of L
</li><li>The direct subexpressions of L appear in the same order as if their corresponding wildcard expressions were extracted in an in-order traversal of P.
</li></ul></li></ul><h1 id="QuerifierLanguage">Querifier Language</h1>
<p>
We use the syntactic power of these s-expressions to define a rules language which querifier knows how to evaluate. For example rules, see [citation needed].
</p>
<p>
The following are value types for the querifier language. The notation <em>&lt;any&gt;</em> represents any one of the following:
</p>
<ul><li><strong>expressions</strong>: which are denoted by <em>&lt;exp&gt;</em>, is one of &lt;list&gt; or &lt;string&gt;. These are <strong>value expressions.</strong>
</li><li><strong>numbers</strong>: denoted <em>&lt;num&gt;</em>, which are the natural numbers.
</li><li><strong>sets</strong>: denoted <em>&lt;set&gt;</em>, which are unordered collections of <em>&lt;exp&gt;</em>
</li><li><strong>dags</strong>: denoted <em>&lt;dag&gt;</em>, which is a directed, acyclic graph of <em>&lt;exp&gt;</em>. (These can be conveniently used to represent a collection of logs where there is no total ordering.)
</li><li><strong>closures</strong>: denoted <em>&lt;closure&gt;</em>, which is a function created by lambda.
</li><li><strong>truth-value</strong>: denoted <em>&lt;truth-value&gt;</em>, which is either <em>&lt;true&gt;</em> or <em>&lt;false&gt;</em>
</li><li><strong>reduction</strong>: special kind of truth value -- represents "unknown." More explicitly, it is the AST which must be evaluated to solve the unknown. It is a simplification of some original rule AST, where the process of simplifying involves partial evaluation of the AST.
</li></ul><h2 id="PrimitiveConstructs">Primitive Constructs</h2>
<p>
For each primitive construct, I will give the pattern which a particular instance must match against in order to qualify as an instance of that construct. I use named expressions solely for explanatory purposes. In place of the #any wildcard, I will use angle-bracketed expressions, which (as stated directly previously) denote type. This makes each of the given patterns syntactically incorrect, but because our language does not have explicit type notation, there is no better way to communicate the contract of each primitive construct. The '|' character denotes logical "or" in typing. If a construct's argument is "&lt;string&gt;|&lt;set&gt;", this means its argument can safely evaluate to either a string or a set without producing type errors. 
</p>
<h3 id="Variables">Variables</h3>
<ul><li><strong>(let #list:(%identifier:#string %value:&lt;any&gt;) %body:&lt;any&gt;)</strong> explicitly extends the environment such that each identifier is bound to each value in the scope of the evaluation of the body.
</li><li><strong>(let-match %pattern:&lt;exp&gt; %target:&lt;exp&gt; %body:&lt;any&gt; %alt:&lt;any&gt;)</strong> implicitly extends the environment for the evaluation of body such that each mapping in the result of the named match of pattern on target is in the environment. If the named match succeeds, a let-match evaluates to what body evaluates to. If it fails, it evaluates to what alt evaluates to.
</li></ul><h3 id="PrimitiveFunctions">Primitive Functions</h3>
<p>
Functions with return type <strong>&lt;set&gt;</strong>:
</p>
<ul><li><strong>(filter %set:&lt;set&gt; %pattern:&lt;exp&gt;)</strong> is the subset of <em>set</em> such that all members of said subset match <em>pattern</em>
</li><li><strong>(list-&gt;set %list&lt;list&gt;)</strong> converts list into a set.
</li><li><strong>(set-&gt;list %set:&lt;set&gt;)</strong> converts set into a list.
</li></ul><p>
Functions with return type <strong>&lt;num&gt;</strong>:
</p>
<ul><li><strong>(len %arg:&lt;exp&gt;|&lt;set&gt;|&lt;dag&gt;)</strong> evaluates to the number of elements in the given collection, or the number of bytes in the given string.
</li><li><strong>(string-&gt;num %string:&lt;string&gt;)</strong> evaluates to the numerical value which string represents. String must use only the characters {-,0,1,...,9}
</li></ul><p>
Functions with return type <strong>&lt;exp&gt;</strong>:
</p>
<ul><li><strong>(quote {expression})</strong> directly constructs an expression value from its s-expression argument. Literal expressions are defined in this manner.
</li><li><strong>(get %n:&lt;num&gt; %list:&lt;list&gt;)</strong> evaluates to the nth element of list.
</li><li><strong>(hash %exp&lt;exp&gt;)</strong> evaluates to the SHA-1 hash of exp.
</li></ul><p>
Functions with return type <strong>&lt;closure&gt;</strong>:
</p>
<ul><li><strong>(lambda %variables:#list:#string %body:#any)</strong> defines %body to be the functoin whose evaluation is closed on the defining environment extended by %variables whose values are given at call time.
</li></ul><p>
Functions with return type <strong>&lt;truth-value&gt;</strong>:
</p>
<p>
We include the sentential connectives:
</p>
<ul><li><strong>(not %arg:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> is true if %arg is false.
</li><li><strong>(and %conjuncts:#list:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> is true if all direct subexpressions of conjuncts evaluate to true.
</li><li><strong>(or %disjuncts:#list:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> is true if at least one direct subexpression of disjuncts evaluates to true.
</li><li><strong>(impl %antecedant:&lt;truth-value&gt;|&lt;reduction&gt; %consequent:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> evaluates to true if either antecedant evaluates to false or consequent evaluates to true.
</li></ul><p>
We include the following predicates:
</p>
<ul><li><strong>(succeeds %left:&lt;exp&gt; %right:&lt;exp&gt; %dag:&lt;dag&gt;)</strong> is true if all of the following are true:
<ul><li>dag contains left
</li><li>dag contains right
</li><li>there is a path from left to right in dag 
</li><li>left and right are not the same expression.
</li></ul></li><li><strong>(&lt; %left:&lt;num&gt; %right:&lt;num&gt;)</strong> is true if left is less than right. 
</li><li><strong>(&gt; %left:&lt;num&gt; %right:&lt;num&gt;)</strong> is true if left is greater than right.
</li><li><strong>(&gt;= %left:&lt;num&gt; %right:&lt;num&gt;)</strong> is true if left is greater than or equal to right.
</li><li><strong>(&lt;= %left:&lt;num&gt; %right:&lt;num&gt;)</strong> is true if left is less than or equal to right.
</li><li><strong>(= %left:&lt;num&gt;|&lt;set&gt;|&lt;sexp&gt;|&lt;truth-value&gt; %right:&lt;num&gt;|&lt;set&gt;|&lt;sexp&gt;|&lt;truth-value&gt;)</strong> is true if one of the following is true:
<ul><li>left and right are equivalent numbers
</li><li>left and right are sets which have the same members
</li><li>left and right are identical strings
</li><li>left and right are lists with the same number of direct subexpressions, and each direct subexpression in left is equivalent to the corresponding direct subexpression in right
</li><li>left and right are both true
</li><li>left and right are both false
</li></ul></li></ul><p>
(Note that the last two conditions for equality make the "=" operation effectively equivalent to the logical biconditional.)
</p>
<p>
We include the common first-order quantifiers:
</p>
<ul><li><strong>(exists %var:#string %universe:&lt;set&gt; %body:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> is true if there is some member of %universe such that when the defining environment is extended in such a way that %var is bound to this value, %body is true. 
</li><li><strong>(forall %var:#string %universe:&lt;set&gt; %body:&lt;truth-value&gt;|&lt;reduction&gt;)</strong> is true if for all members of %universe, when the defining environment is extended in such a way that %var is bound to this value, %body is true.
</li></ul><h3 id="Assertions">Assertions</h3>
<p>
Assertions denote particular points of interest to the rule writer. Inserting an assertion into a particular piece of code denotes that the writer would like to be notified if the body of the assertion evaluates to false.
</p>
<ul><li><strong>(assert %name:#string %dependencies:#list:#string %body:&lt;any&gt;)</strong> always evaluates to body, but if body is false, has the side effect of evaluating each variable in dependencies and storing their values in the global list of failed assertions.
</li></ul>

</body>
</html>

