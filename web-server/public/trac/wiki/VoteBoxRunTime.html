
<html><head><link rel="stylesheet" href="trac.css" type="text/css" />
</head><body>

<h1 id="VoteBoxSoftwareSpecification:UserInterfaceModule">VoteBox Software Specification: User Interface Module</h1>
<p>
<strong>Kyle Derr, Daniel Sandler, Ted Torous</strong>
</p>
<p>
<em>written by: <a class="mail-link" href="mailto:derrleyATrice.edu"><span class="icon">​</span>Kyle Derr</a></em>
</p>
<p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#VoteBoxSoftwareSpecification:UserInterfaceModule">VoteBox Software Specification: User Interface Module</a>
    <ol>
      <li>
        <a href="#Usage">Usage</a>
      </li>
      <li>
        <a href="#SummaryandModuleDefinition">Summary and Module Definition</a>
      </li>
      <li>
        <a href="#Ballot">Ballot</a>
        <ol>
          <li>
            <a href="#BallotContent">Ballot Content</a>
          </li>
          <li>
            <a href="#BallotConfiguration">Ballot Configuration</a>
            <ol>
              <li>
                <a href="#BallotXMLFile">Ballot XML File</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#Ballotclass">Ballot class</a>
            <ol>
              <li>
                <a href="#Properties">Properties</a>
              </li>
              <li>
                <a href="#PropertiesClass">Properties Class</a>
              </li>
              <li>
                <a href="#Cards">Cards</a>
              </li>
              <li>
                <a href="#Cardclass">Card class</a>
              </li>
              <li>
                <a href="#CardElementclass">CardElement? class</a>
              </li>
              <li>
                <a href="#SelectableCardElementclass">SelectableCardElement class</a>
              </li>
              <li>
                <a href="#Themediabundle">The media bundle</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#BallotParserclass">BallotParser class</a>
          </li>
          <li>
            <a href="#CastBallots">Cast Ballots</a>
            <ol>
              <li>
                <a href="#CastBallotClass">CastBallot Class</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#UserInterface">User Interface</a>
        <ol>
          <li>
            <a href="#IDrawableinterface">IDrawable interface</a>
          </li>
          <li>
            <a href="#IViewinterface">IView interface</a>
          </li>
          <li>
            <a href="#MDXViewclass">MDXView class</a>
          </li>
          <li>
            <a href="#ViewManagerclass">ViewManager class</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Driver">Driver</a>
        <ol>
          <li>
            <a href="#Driverclass">Driver class</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<p>
Readers are encouraged to use the <a class="ext-link" href="http://votebox.cs.rice.edu/doxygen/"><span class="icon">​</span>Doxygen Docs</a> as a more specific guide to the program's API. Packages relevant to this document are defined in <tt>ballotbox.middle</tt> or sub packages.
</p>
<h2 id="Usage">Usage</h2>
<p>
Using already built jar file
</p>
<pre class="wiki">java -jar votebox.jar [serial number]
</pre><p>
or
</p>
<pre class="wiki">java -Djava.library.path=path/to/directory/with/libSDL_wrap/file -jar votebox.jar [serial number]
</pre><p>
to make the SDL view available (note that SDL must still be selected in the appropriate configuration file).
</p>
<h2 id="SummaryandModuleDefinition">Summary and Module Definition</h2>
<p>
In this document we define specification for the user interface module of the <a class="missing wiki" href="/wiki/VoteBox" rel="nofollow">VoteBox?</a> voting machine. By "user interface," we mean the module which defines all behaviors that relate to a single voter's interaction with the machine. This notably includes those behaviors which produce the visual software controls which a voter may interact with in order to record his preference in an election, as well as the behavior that creates immutable cast ballots that other parts of the system use. The user interface module keeps no state between voting sessions (where a single voting session is defined as the interval of time where a single voter uses the software to record his preferences in an election). In fact, a different instance of this module is created for every unique voter, and, throughout the software's run time, at most, one instance of this module exists at any single point in time.
</p>
<dl class="wiki"><dt>Aside</dt><dd>It is important to note that in the domain of human factors testing, the only relevant module is this one. As a consequence of this, all human factors research related design goals are specified here. Because the goals that we have specified for human factors research are, in some cases, necessarily in conflict with those that we have specified for security research, the parts of this document that are explicitly stated as only beneficial to human factors research can be assumed to be left out of any version which we propose should be placed under the scrutiny of an expert in computer security.
</dd></dl>
<p>
Because the user interface module (which we will abbreviate UI) defines the parts of the software which directly affect the voter's experience, it is useful (towards the goal of a definition for this module) to give a concise description of what a voter should expect when he interacts with our machine. The voter will be able to use hardware controls to select candidates, navigate the ballot, and cast a finished ballot. Our design allows for flexibility in which hardware controls are used in an implementation. (For example, touch screens, scroll wheels, and arrow keys are reasonable solutions.) While at the machine, the voter will be presented with a series of screens. First, he will navigate through screens which will explain the election. Next, he will be presented with a series of races in which he can vote. After he votes, he will be presented with a summary screen which will allow him to confirm that the machine has accurately recorded his preferences in the races in which he can vote. Finally, the user will confirm his vote, the ballot will be cast, and the machine will appear to "restart" (as the UI module will be thrown away and recreated for the next voter).
</p>
<p>
The UI will be independently constructed by the [:VoteBoxBackend:Back End] module) for each individual voter who comes into contact with the machine, and will only exist in memory while the voter is interacting with the machine. When the voter declares his intent to cast his ballot, the modules we define here will convey the ballot state to another module in a form that is immutable. The driver component will then release all references to the mutable ballot.
</p>
<p>
<strong>THIS NEEDS TO BE RETHOUGHT AND POSSIBLY PLACED ELSEWHERE</strong><br /> The modules we define here will interact as follows (<strong>ADD A DIAGRAM</strong>). The hardware with which the voter will interact will trigger events in the view. The view's job is simply to display screens to the voter and accept the voter's input. This view will have been constructed by a view manager, whose job is to control all the changes in the view which happen in response to user interface events. The view manager will respond to events by asking the view to change what is being displayed on the screen. A new view manager (and corresponding view) is constructed by the user interface driver every time a new vote session is started. When the voter communicates his intent to cast his ballot, the view manager will ask the ballot to create an immutable representation of itself, which it will hand to the user interface driver. The user interface driver will then release its reference to the view manager, and pass the cast ballot to the vote recording module.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot)" rel="nofollow">Anchor(sec:ballot)?</a>
</p>
<h2 id="Ballot">Ballot</h2>
<p>
Here we define what is referred to throughout this document as a <em>ballot.</em> Ballot definition, in general, is relevant to the UI definition in that each form defined here is either interpreted, modified, or created by the UI.
</p>
<p>
In defining the user interface, this document includes references to many (different) structural definitions for what we refer to, conceptually, as a <em>ballot.</em> In this section we hope remedy confusion by giving a concrete definition for each ballot type, as well as by offering some explanation as to why there are different definitions for what a <em>ballot</em> is and when each one is appropriate.
</p>
<p>
Here, it helps to use the older, punch card election system (specifically, the ballots that it uses) as an appropriate explanatory analogue, as our ballots are conceptually analogous. One form of it is created before an election by some sort of election administrator. This might be appropriately called a <em>definition</em> of ballot <em>content.</em> Content, here, includes a definition of everything that a voter can see (including explanatory information about races and the candidates' actual names) as well as a definition for the method which the voter can use to communicate his preference in each race. From this original, a copy is made for and modified by each voter (when said voter records his preferences). This, of course, happens on election day. Once a voter is finished modifying his personal copy of the ballot, he places it in an environment which (supposedly) makes it safe from further modification. These three forms which a ballot takes represent three different and distinct definitions for "ballot" which we will use.
</p>
<h3 id="BallotContent">Ballot Content</h3>
<p>
Each of our defined <em>ballot</em> forms claim to represent, conceptually, the same thing. For this reason, we have defined and made use of certain terminology in order to accurately refer to different components of the ballot.
</p>
<dl class="wiki"><dt>Ballot Content Definition</dt><dd>
<ul><li>A <em>ballot</em> can have
<ul><li><em>card</em>s
</li><li><em>properties</em>
</li></ul></li><li>A <em>card</em> has a unique ID, and can also have
<ul><li><em>card element</em>s
</li><li><em>properties</em>
</li></ul></li><li>A <em>card element</em> has a unique ID and can also have 
<ul><li><em>properties</em>
</li></ul></li></ul></dd></dl>
<p>
A <em>ballot</em> is divided into many <em>cards,</em> each of which is divided into many <em>card elements.</em> The most common use of this hierarchy of subdivision is the case where each race in an election is represented with a <em>card</em>, while each candidate in each race is represented with a <em>card element</em>. Our purpose in being generic with terminology is to claim that these subdivisions are generic, even though necessarily used to represent certain notions. More specifically, in our design, races are necessarily represented as <em>cards</em>; candidates, as elements. However, <em>cards</em> and <em>card elements</em> are also used to represent other things. <em>Card elements</em> can be used, for example, to represent explanatory bits on the ballot that cannot be "voted" for, such as a referendum description or a race title. <em>Cards</em> can be used to represent a section in which no selections are made at all, but only consist of explanatory bits, such as a set of instructions. Both <em>cards</em> and <em>card elements</em> are identified by 
</p>
<p>
<em>Properties</em> help to more specifically define elements in the ballot. A <em>property</em>, as we have defined it, is a ballot configuration parameter that an election administrator has the power to set. The voting machine will check these <em>properties</em> as part of the process that it uses to determine what to do with each <em>card</em> and <em>card element</em>. For example, an election administrator can choose to place a specific <em>card element</em> as belonging to a particular political party, or define that on a specific <em>card</em>, a given number of elements can be selected simultaneously.
</p>
<h3 id="BallotConfiguration">Ballot Configuration</h3>
<p>
We use the term <em>ballot configuration</em> to mean the ballot that is created by an election administrator before an election. Because this version of the ballot will need to be persisted on some sort of storage until the time of the election, and then copied to each machine once for every participating, registered voter, the <em>ballot configuration</em>  can be thought of as a set of files. These files are then parsed by the voting machine at run time in order to make a "copy" of the ballot which the voter can modify and cast.
</p>
<h4 id="BallotXMLFile">Ballot XML File</h4>
<p>
The ballot's content is defined in an XML file which conforms to the format we define here.
</p>
<p>
The file makes use of the following five tags: <tt>&lt;Ballot&gt;</tt>, <tt>&lt;Card&gt;</tt>, <tt>&lt;CardElement&gt;</tt>, <tt>SelectableCardElement</tt>, and <tt>&lt;Property&gt;</tt>.
</p>
<p>
The <tt>Ballot</tt> tag, as would be expected, is used to define a ballot. The first tag encountered in the file must be a <tt>Ballot</tt> tag, and no other tag in the file is allowed to be. All other tags must be defined inside the ballot tag. It has no attributes.
</p>
<p>
<tt>CardElement</tt>, <tt>SelectableCardElement</tt>, and <tt>Card</tt> may be used inside the top-level <tt>Ballot</tt> tag to define the existence of <em>card elements</em> and <em>cards</em>. The <tt>SelectableCardElement</tt> tag is used to denote <em>card elements</em> that can be chosen by the voter. (For example, in the case where a <em>card element</em> represents a candidate in a rate, this candidate would be defined in the XML as a <tt>SelectableCardElement</tt>.) The <tt>Card</tt> tag can only be used inside the top-level <tt>Ballot</tt> tag, and both <tt>CardElement</tt> and <tt>SelectableCardElement</tt> can only be used inside a <tt>Card</tt> tag. Each 
<dl class="wiki"><dt>Syntax</dt><dd>
</p>
<pre class="wiki">Where T is one of {Card, CardElement, SelectableCardElement}
&lt;T uid="aUid"&gt;
...
&lt;/T&gt;
</pre></dd></dl>
<p>
The <tt>Property</tt> tag is used to express the notion of properties referenced above. <strong>Properties</strong> can be thought of as typed entries in a dictionary. Each property that is defined can have only one value. For a complete list of supported keys and values, please see the <a class="ext-link" href="http://swooh.com/voteboxdoc/ballotbox/middle/Properties.html"><span class="icon">​</span>JavaDoc</a>. A <tt>Property</tt> tag can belong to any other tag in the definition, not including other <tt>Property</tt> tags, and including the top-level <tt>Ballot</tt> tag. Each property definition and its corresponding value will follow this syntax:
</p>
<pre class="wiki">&lt;property name="key" type="string" value="value"&gt;&lt;/property&gt;`
</pre><p>
To define (in the configuration file) a <tt>Card</tt> as belonging to a <tt>Ballot</tt>, place a <tt>&lt;card&gt;</tt> tag inside the <tt>&lt;ballot&gt;</tt> tag. A card must define an int property named "uid." (UIDs, of course, must be unique across any given ballot.  This is enforced at parse-time.)
</p>
<p>
To define (in the configuration file) a <tt>CardElement</tt> as belonging to a <tt>Card</tt>, place a <tt>&lt;cardelement&gt;</tt> tag inside the <tt>&lt;card&gt;</tt> tag of its parent. A card element must define both an int property named "uid," and a boolean property named selectable. The uid must be unique across the ballot.  For card elements which are intended to be selectable (such as card elements which will hold a candidate's name), set the selectable property to true. Otherwise, set it to false.
</p>
<p>
If a certain trait is required of a ballot, card, or a card element, then the definition of that trait must be specified in the attributes of the either the card or card element. If a trait is optional it can be defined in a property tag. For example, "<a class="missing wiki" href="/wiki/MaxImageSize" rel="nofollow">MaxImageSize?</a>" is an optional trait, defined across the whole ballot, that defines the number of images associated with every card element (indexed from zero onward). Its default state (if not initialized) is zero, corresponding to one element per card element.  (TBD: what other traits are optional for what type of ballots?)
</p>
<p>
For an example configuration file, please see Figure 1.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(fig%3Aconfigfile)" rel="nofollow">Anchor(fig:configfile)?</a>
</p>
<pre class="wiki">&lt;?xml ?&gt;
&lt;ballot&gt;
    &lt;property name="county" type="string" value="Harris"&gt;&lt;/property&gt;
    &lt;property name="straight-ticket" type="boolean" value="true"&gt;&lt;/property&gt;
    &lt;property name="MaxImageSize" value="1"&gt;&lt;/property&gt;
    &lt;!-- This is an informational card --!&gt;
    &lt;card uid="54311"&gt;
        &lt;cardelement uid="512" selectable="false"&gt;&lt;/cardelement&gt;
    &lt;/card&gt;
    &lt;!-- This is a race card --!&gt;
    &lt;card uid="54312"&gt;
        &lt;cardelement uid="60001" selectable="true"&gt;&lt;/cardelement&gt;
        &lt;cardelement uid="60002" selectable="true"&gt;&lt;/cardelement&gt;
        &lt;!-- uids do not have to be ascending or descending, only unique --!&gt;
        &lt;cardelement uid="60009" selectable="true"&gt;&lt;/cardelement&gt;
    &lt;/card&gt;
&lt;/ballot&gt;
</pre><blockquote>
<p>
Figure 1: <strong>Example ballot configuration file.</strong> Follow this
</p>
</blockquote>
<p>
format when creating ballot configuration files.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Aballot)" rel="nofollow">Anchor(sec:ballot:ballot)?</a>
</p>
<h3 id="Ballotclass">Ballot class</h3>
<p>
The <tt>Ballot</tt> class represents the runtime version of the ballot. This means that a <tt>Ballot</tt> contains both <tt>Properties</tt> (see <a href="/Wiki#sec:ballot:ballot:properties">here</a>) and <tt>Card</tt>s. The <tt>Card</tt>s will be stored in memory as a <tt>List&lt;Card&gt;</tt>.
</p>
<dl class="wiki"><dt>State</dt><dd>The <tt>Ballot</tt> contains both a <tt>Properties</tt> reference and a <tt>List&lt;Card&gt;</tt>.
</dd><dt>Construction</dt><dd>Construction is handled exclusively by the <tt>BallotParser</tt>. The constructor can only be accessed from the scope of the user interface assembly. The <tt>BallotParser</tt> is the only user interface component which constructs new <tt>Ballot</tt>s that can be used by other parts of the user interface system. <tt>Ballot</tt>s are not accessible (at all) from outside the user interface system.
</dd><dt>Methods</dt><dd><tt>Ballot</tt> defines the following methods:
</dd><dt>public <a class="missing wiki" href="/wiki/CastBallot" rel="nofollow">CastBallot?</a> makeCastBallot()</dt><dd>Generates a <tt>CastBallot</tt> that represents this ballot. The <tt>CastBallot</tt> cannot be modified.
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Aballot%3Aproperties)" rel="nofollow">Anchor(sec:ballot:ballot:properties)?</a>
</p>
<h4 id="Properties">Properties</h4>
<p>
After a ballot's properties are parsed from the ballot configuration file, they are stored in the ballot's state. They are stored in an instance of the <tt>Properties</tt> class.
</p>
<h4 id="PropertiesClass">Properties Class</h4>
<p>
The <tt>Properties</tt> class allows for the ballot to have unique traits and be customizable by storing parsed properties of the ballot.
</p>
<dl class="wiki"><dt>State</dt><dd><tt>Properties</tt> has a <tt>Dictionary&lt;string,string&gt;</tt> as state. In addition, all the keys used in the dictionary will be declared as final constants.  This is done to reduce the number of typos and make for easier auditing/verification.
</dd><dt>Construction</dt><dd><tt>Properties</tt> will have only one, default, initializing constructor.
</dd><dt>Methods</dt><dd><tt>Properties</tt> defines the following methods:
</dd><dt>internal void add(string key, string value)</dt><dd>This method allows for the addition of a new key and value to the dictionary.
</dd><dt>public string getString(string key)</dt><dd>Get the string value mapped to a given key. If this value has been declared to not exist as type string, this method will throw an exception.
</dd><dt>public int getInt(string key)</dt><dd>Get the int value mapped to a given key. If this value has been declared to not exist as type int, this method will throw an exception.
</dd><dt>public int getDouble(string key)</dt><dd>Get the double value mapped to a given key. If this value has been declared to not exist as type double, this method will throw an exception.
</dd><dt>public int getBoolean(string key)</dt><dd>Get the boolean value mapped to a given key. If this value has been declared to not exist as type boolean, this method will throw an exception.
</dd><dt>public List getList()</dt><dd>This method returns a List of all the property mappings in the <tt>Dictionary</tt>.
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Acards)" rel="nofollow">Anchor(sec:ballot:cards)?</a>
</p>
<h4 id="Cards">Cards</h4>
<p>
The entire ballot is rendered before runtime. The ballot is divided into <tt>Card</tt>s.  <tt>Card</tt>s are divided into <tt>CardElement</tt>s. Each <tt>CardElement</tt> is visually represented by a single, pre-rendered image which is included in the ballot's media bundle.  Conceptually, a ballot can be divided into informational pieces and races (with each race having multiple candidates); here we represent races with <tt>Card</tt>s, candidates with <tt>CardElement</tt>s.
</p>
<p>
It then follows that <tt>Card</tt>s either communicate electoral races or informational pieces intended to be read by the voter. We mandate that informative <tt>Card</tt>s will not carry any races on them, and race <tt>Card</tt>s will at most contain one race. (The view may, of course, decide to display more than once <tt>Card</tt> and hence more than one race at a time.) Each <tt>Card</tt> and <tt>CardElement</tt> will have its own unique (across the whole ballot and, by extension, the whole election) ID.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Aballot%3Acard)" rel="nofollow">Anchor(sec:ballot:ballot:card)?</a>
</p>
<h4 id="Cardclass">Card class</h4>
<p>
represent either a nugget of general information about the election or an individual race in which the voter is allowed to report his preferred outcome. Informational <tt>Card</tt>s contain only one element, while race <tt>Card</tt>s contain many elements: one element that describes the race, and one selectable element for each candidate.
</p>
<dl class="wiki"><dt>State</dt><dd>The <tt>Card</tt> will hold only a list of <tt>CardElements</tt> as state.
</dd><dt>Construction</dt><dd>Upon construction, the card will be handed its list of <tt>CardElements</tt>
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Aballot%3Acardelement)" rel="nofollow">Anchor(sec:ballot:ballot:cardelement)?</a>
</p>
<h4 id="CardElementclass"><a class="missing wiki" href="/wiki/CardElement" rel="nofollow">CardElement?</a> class</h4>
<p>
A <tt>CardElement</tt> represents a pre-rendered section of a <tt>Card</tt>. A <tt>CardElement</tt> has an accessible media bundle.  <tt>CardElement</tt> also implements the <tt>IDrawable</tt> (see <a href="/Wiki#sec:ui:idrawable">here</a>) interface.
</p>
<dl class="wiki"><dt>State</dt><dd>The <tt>CardElement</tt> holds its media bundle and a reference to its parent <tt>Card</tt> as state.
</dd><dt>Construction</dt><dd>When constructing a new <tt>CardElement</tt>, you must provide it with a media bundle.
</dd><dt>Methods</dt><dd><tt>CardElement</tt> defines the following behaviors.
</dd><dt>Image getImage(int size)</dt><dd>Get an image from the media bundle given a specific size. This method returns a pre-rendered image given a certain integer size. The media bundle has an size-ordered list of images. This number designates the index of the desired element in that list.
</dd><dt>Audio getAudio()</dt><dd>Get the current audio file associated with this <tt>CardElement</tt>.
</dd></dl>
<h4 id="SelectableCardElementclass">SelectableCardElement class</h4>
<p>
<tt>SelectableCardElement</tt> is a class that extends <tt>CardElement</tt>, and conceptually represents an item in a race which can be both selected (voted for) and focused on. It follows, then, that a <tt>SelectableCardElement</tt> can exist in four abstract states: <strong>default, selected, focused, and focused-selected</strong>. The <strong>default</strong> state is the state that should appear the first time <tt>SelectableCardElement</tt> is displayed. A <strong>selected</strong> <tt>SelectableCardElement</tt> is one which has been chosen by the voter as preferred. A <strong>focused</strong> <tt>SelectableCardElement</tt> is an element that the voter has navigated to specifically in order to perform some action (like selecting). A <tt>focused-selected</tt> <tt>SelectableCardElement</tt> is one that has been selected and focused at the same time. Support for focusing is not needed on touch-screen systems. There will be an image in the media bundle which can display the <tt>SelectableCardElement</tt> in each of these four states.
</p>
<p>
In addition to having the properties of <tt>CardElement</tt>, it has these additional properties:
</p>
<dl class="wiki"><dt>State</dt><dd><tt>SelectableCardElement</tt> will holds its abstract state as a member field. This state object will be delegated to in order to perform state-specific tasks. The <tt>SelectableCardElement</tt> will also hold some additional media in its media bundle so that it may display (visually or via audio) that the state of the element has changed (if it has).
</dd><dt>Methods</dt><dd><tt>SelectableCardElement</tt> defines the following methods:
</dd><dt>void toggle()</dt><dd>This method will be called when the user has selected (voted for or decided not to vote for) this element.  The image associated with this element will change to reflect the changed state of the element. This method will raise the <tt>SelectedEvent</tt> if its new state is <strong>selected</strong>, and will raise the <tt>DeselectedEvent</tt> if its new state is <strong>deselected</strong>. It will perform both of these tasks by delegating to the state object.
Pressing toggle multiple times on a <tt>SelectableCardElement</tt> will cause a response which is parameterized by the properties of the card.  For example, if a voter is ranking candidates, toggling a second candidate will not deselect the first.
</dd><dt>void focus()</dt><dd>This method will cause the current element to change its associated image to reflect that the current element's state has been changed to <strong>focused</strong> (or <strong>focused-selected</strong> if the element was already selected). To do this, it will delegate to the member state object. This method will raise the <tt>FocusedEvent</tt>.
</dd><dt>void unFocus()</dt><dd>This method will cause the current element change its state to <strong>default</strong> (or <strong>selected</strong> if the element was already selected.) This will cause the element to change its associated image and raise a <tt>UnfocusedEvent</tt>. To do this, it will delegate to the member state object.
</dd><dt>Events</dt><dd><tt>SelectableCardElement</tt> defines the following public events which can be subscribed to:
</dd><dt><a class="missing wiki" href="/wiki/SelectedEvent" rel="nofollow">SelectedEvent?</a></dt><dd>This event is raised when the element is selected.
</dd><dt><a class="missing wiki" href="/wiki/DeselectedEvent" rel="nofollow">DeselectedEvent?</a></dt><dd>This even is raised when the elment is deselected.
</dd><dt><a class="missing wiki" href="/wiki/UnfocusedEvent" rel="nofollow">UnfocusedEvent?</a></dt><dd>This event is raised when the element is unfocused.
</dd><dt><a class="missing wiki" href="/wiki/FocusedEvent" rel="nofollow">FocusedEvent?</a></dt><dd>This event is raised when the element is focused.
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Aballot%3Amediabundle)" rel="nofollow">Anchor(sec:ballot:ballot:mediabundle)?</a>
</p>
<h4 id="Themediabundle">The media bundle</h4>
<p>
For the purpose of this documentation, a media bundle is a set of images and audio files, each of which can communicate to the voter both a <tt>CardElement</tt>'s information and (possible) state.
</p>
<p>
Image files on disk should be in PNG format and should be named by the UID which they claim to represent. An image who is rendered to represent the <tt>CardElement</tt> with UID <tt>60001</tt> would be named <tt>60001.png</tt>. Images also must be pre-rendered to reflect different states which <tt>SelectableCardElements</tt> can be in. An image who is rendered to represent the <tt>CardElement</tt> with UID <tt>60001</tt> in the focused state would be named <tt>60001_focused.png</tt> on disk.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Adriver%3Aballotparser)" rel="nofollow">Anchor(sec:driver:ballotparser)?</a>
</p>
<h3 id="BallotParserclass">BallotParser class</h3>
<p>
<tt>BallotParser</tt> class is to act as a factory for blank ballots. We consider a blank ballot to be a ballot that has all <tt>SelectableCardElement}(s) in \textbf{default</tt> state. To create blank ballots, the parser will read ballot configuration information from disk, and use it as a guide for how the ballot structure should be created.
</p>
<dl class="wiki"><dt>State</dt><dd>The <tt>BallotParser</tt> will keep the location of the ballot configuration file as state.
</dd><dt>Construction</dt><dd>A new <tt>BallotParser</tt> must be provided with the location of the ballot configuration file when it is constructed.
</dd><dt>Methods</dt><dd><tt>BallotParser</tt> defines the following public methods:
</dd><dt>Ballot getNewBallot()</dt><dd>Call this method to create a new blank ballot.
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Acastballot)" rel="nofollow">Anchor(sec:ballot:castballot)?</a>
</p>
<h3 id="CastBallots">Cast Ballots</h3>
<p>
A cast ballot is a ballot that has been edited by the voter and is considered to be the voter's final preference. Here, we define that our cast ballot structure has the property of being immutable: once it is created it cannot be changed. A <tt>CastBallot</tt> can only be created by the makeCastBallot() method in <tt>Ballot</tt>. The ensures that there only is one source for valid <tt>CastBallots</tt>--no other part of the system can create <tt>CastBallot</tt>s. A <tt>CastBallot</tt> will carry some basic information that will allow for it to be counted. This includes a list of races and a list of selection(s) in each of those races.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aballot%3Acastballot%3Acastballot)" rel="nofollow">Anchor(sec:ballot:castballot:castballot)?</a>
</p>
<h4 id="CastBallotClass">CastBallot Class</h4>
<p>
A <tt>CastBallot</tt> object will be created by <tt>Ballot</tt> internally. The <tt>makeCastBallot()</tt> method in <tt>Ballot</tt> will create the <tt>CastBallot</tt> by iterating though the ballot's list of <tt>Card</tt>s and recording the state of those which are <tt>instanceof SelectableCardElement</tt>. For each element that is in <strong>selected</strong> state, its UID is recorded along with the UID of the <tt>Card</tt> who owns it. Thus the data is stored in a list of tuples, <tt>&lt;UID,List&lt;UID&gt;&gt;</tt> One half of the tuple contains the UID of a given <tt>Card</tt> while the other half of the tuple contains the UIDs of all the selected elements on that <tt>Card</tt>. Basically, a <tt>CastBallot</tt> is a list of races and votes in those races.
</p>
<dl class="wiki"><dt>State</dt><dd><tt>CastBallot</tt> keeps a list of tuples which can be accessed but not modified.
</dd></dl>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aui)" rel="nofollow">Anchor(sec:ui)?</a>
</p>
<h2 id="UserInterface">User Interface</h2>
<p>
In defining our user interface, we necessarily abstract the view's event-response behavior (event handlers) from the behavior which actually displays images on the screen. We do this so our user interface module has a certain degree of portability. If, later, we decide to change the API that is used to actually display images on the screen, we would only need to change our display implementation.  The event-response behaviors are defined such that they communicate with a view interface. It follows from this, then, that here we should define this interface, our first class that implements it, and our event-response behavior.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aui%3Aidrawable)" rel="nofollow">Anchor(sec:ui:idrawable)?</a>
</p>
<h3 id="IDrawableinterface">IDrawable interface</h3>
<p>
Any item that is to be drawn on to the display must implement the this interface. The interface has only one method:
</p>
<dl class="wiki"><dt>string getImage(int size)</dt><dd>Gets path to the pre-rendered image that corresponds to this <tt>IDrawable</tt>.  The size parameter refers to the image's index in the media bundle.
</dd></dl>
<h3 id="IViewinterface">IView interface</h3>
<p>
A view must conform to this interface. The view's job is to display ballot information on the screen and also, to capture user input.  Therefore, a view must define how to display an <tt>IDrawable</tt> (both the smallest independently renderable ballot object and the object who accepts all user interface events) on the screen. In order for the <tt>ViewManager</tt> (see <a href="/Wiki#sec:ui:viewmanager">here</a>) to make layout decisions (configure the display however it likes), it needs to have access to three methods in every implemented view.
</p>
<dl class="wiki"><dt>void draw(IDrawable element, int x, int y, int size)</dt><dd>This method defines the behavior of the view when it is asked to draw a given <tt>IDrawable</tt> to the screen at a certain location. Subsequent calls to this method (given the same location) result in an "overlapping" effect. The coordinate system assumed here is the standard one, with the origin at the top-left corner of the screen, positive x axis extending rightward from the origin, and positive y axis extending downward from the origin.  This function allows for both navigation and election information to be displayed. Because <tt>CardElement</tt> implements <tt>IDrawable</tt>, races can be displayed. Navigation controls can be displayed insofar as the navigation control elements implement the <tt>IDrawable</tt> interface.
</dd><dt>void invalidate(IDrawable element)</dt><dd>This method allows the <tt>ViewManager</tt> to tell the view that a certain <tt>IDrawable</tt>'s image has changed. Here, the implementing view  should do what is necessary to display the <tt>IDrawable</tt>'s current image.
</dd><dt>void clearDisplay()</dt><dd>This method defines the behavior of the view when it is asked to clear the display of all the <tt>IDrawable</tt>s that it currently is displaying.
</dd><dt>void run()</dt><dd>This method puts the view into its event loop.
</dd><dt>void dispose()</dt><dd>This method disposes of all the view's components. This method should be called before a reference to a view is nulled.
</dd></dl>
<h3 id="MDXViewclass">MDXView class</h3>
<p>
Our view will use the Managed Direct3D library to project <tt>IDrawable</tt> objects onto the screen. Each <tt>IDrawable</tt> will be represented as a Direct3D two-dimensional sprite which is textured by the image accessed by <tt>IDrawable.getImage(...)</tt>.
</p>
<p>
In this first iteration of development, we are using the Managed DirectX 9.0 API (version 1.0.2902.0) to render images onto a .NET Windows Form. At present time, we do not have access to the XBox 360 SDK. We can only tentatively speculate that the beta version of Managed DirectX 9.0 version 2.0.0.0 is <em>somewhat</em> like the Managed DirectX API for XBox 360. In addition, we are completely without knowledge of the input device API on an XBox 360. These two facts, coupled with the fact that documentation for version 2.0.0.0 of the Managed DirectX API is harshly lacking in substance, has led us to choose version 1.0.2902.0 for our preliminary build. If this software eventually does explicitly target the XBox 360, both aforementioned components of the <tt>MDXView</tt> class (both the reliance on Windows Forms as an API for user input and the reliance on version 1.0.2902.0 of the Managed DirectX API) will need to be modified. We assume, however, that this modification will be <em>fairly</em> painless, given the fact that our familiarity with the DirectX API, in general, is evidenced by our use of version 1.0.2902.0.
</p>
<p>
<a class="missing wiki" href="/wiki/Anchor(sec%3Aui%3Aviewmanager)" rel="nofollow">Anchor(sec:ui:viewmanager)?</a>
</p>
<h3 id="ViewManagerclass">ViewManager class</h3>
<p>
The <tt>ViewManager</tt>'s job is twofold. First, it's job is to command the view to display ballot information in the form of individual <tt>CardElement</tt>s. Second, it defines how the view should respond to events.
</p>
<dl class="wiki"><dt>State</dt><dd>The <tt>ViewManager</tt> will hold, as state, a reference to the current <tt>Ballot</tt> and <tt>IView</tt>. The <tt>ViewManager</tt> will use the <tt>IView</tt> it holds to draw <tt>CardElement</tt>s to the screen, and it will delegate appropriately to the <tt>Card</tt>s and <tt>CardElement</tt>s when responding to user interface events.
</dd><dt>Construction</dt><dd>The <tt>ViewManager</tt> will be handed a reference to the current <tt>Ballot</tt>, but will construct a new view. It is this reconstruction which makes the machine appear to "restart" between voting sessions.
</dd><dt>Event Handlers</dt><dd>The <tt>ViewManager</tt> must define several event handlers. This is done so that event handling behavior is abstracted from the view implementation. These methods should be called by any implementing <tt>IView</tt> in response to user interface events.
</dd><dt>void select(IDrawable ce)</dt><dd>This method is called when the voter selects a specific candidate in a race or selects a navigation control. This method defines the response of the view to report that an actual "vote" has been recorded, or that the visual ballot representation has been changed.
</dd><dt>void select()</dt><dd>This method is called when the voter uses a hardware key to select a specific candidate in a race or selects a navigation control. Here, the currently focused <tt>IDrawable</tt> is assumed to be the element that the user intends to select.
</dd><dt>void focus(IDrawable ce)</dt><dd>This method is called when the voter focuses on a specific candidate in a race.  This method usually is called when something is "moused over."
</dd><dt>void castBallot()</dt><dd>This method is called when the voter indicates that he would like to cast his ballot. This behavior can also be defined in the <tt>ViewManager</tt> as a special case of the <tt>select(...)</tt> method. We include an explicit method for the notion of ballot casting so that <em>separate</em> hardware can be used to convey the notion of a voter being "done."
</dd><dt>void moveFocusLeft()</dt><dd>This method is called when the voter presses the "left arrow key" (or equivalent hardware) on the machine. This method is called when the user has indicated that he would like to focus the item directly to the left of the one which is currently focused.
</dd><dt>void moveFocusRight()</dt><dd>This method is called when the voter presses the "right arrow key" (or equivalent hardware) on the machine. This method is called when the user has indicated that he would like to focus the item directly to the right of the one which is currently focused.
</dd><dt>void moveFocusUp()</dt><dd>This method is called when the voter presses the "up arrow key" (or equivalent hardware) on the machine. This method is called when the user has indicated that he would like to focus the item directly above the one that is currently focused.
</dd><dt>void moveFocusDown()</dt><dd>This method is called when the voter presses the "down arrow key" (or equivalent hardware) on the machine. This method is called when the user has indicated that he would like to focus the item directly below the one which is currently focused.
</dd><dt>void moveFocusNext()</dt><dd>This method is called when the voter, using a voting machine with only two buttons, presses the "forward arrow key" (or equivalent hardware) on the machine.  This method is called when the user has indicated that he would like to focus the item directly after the one which is currently focused.
</dd><dt>void moveFocusBack()</dt><dd>This method is called when the voter, using a voting machine with only two buttons, presses the "backwards arrow key" (or equivalent hardware) on the machine.  This method is called when the user has indicated that he would like to focus the item directly before the one which is currently focused.
</dd><dt>void nextPage()</dt><dd>This method is called when the voter, using a hardware button, communicates his interest to go to the next page.
</dd><dt>void previousPage()</dt><dd>This method is called when the voter, using a hardware button, communicates his interest to go to the previous page.
</dd></dl>
<h2 id="Driver">Driver</h2>
<p>
The driver is the only part of the user interface module that is voter independent. It will initialize the (other) necessary components in the user interface every time a new voter gains access to a machine. The driver is implemented in the <tt>Driver</tt> class (see <a href="/Wiki#sec:driver:driver">here</a>) and will follow the steps identified here.
</p>
<ul><li><strong>Loading the ballot:</strong> The <tt>Driver</tt> will instantiate a new <tt>BallotParser</tt> so that it may get a <tt>Ballot</tt> object with which it can communicate ballot information to the voter and record his preference. It will keep a reference to this <tt>Ballot</tt> for the duration of the voter's session.
</li><li><strong>Launch a <tt>ViewManager</tt>:</strong> The <tt>Driver</tt> will construct a new <tt>ViewManager</tt> and hand it the <tt>Ballot</tt> object which it created in the previous step. (This <tt>ViewManager</tt>, of course, is responsible for constructing the view.)
</li><li><strong>Handle the voter's intent to cast a ballot:</strong> When the voter decides that he is done modifying his ballot, he will communicate his intent to cast to an <tt>IView</tt>, who will notify the <tt>ViewManager</tt>, who will notify the <tt>Driver</tt>. The <tt>Driver</tt> will then ask the voter's <tt>Ballot</tt> to construct a <tt>CastBallot</tt> representation of itself. The Driver will then pass this immutable ballot structure to the capture interface, which manages the storage and recording of the ballot.
</li><li><strong>Reset:</strong> After the ballot has been cast, the <tt>Driver</tt> will dispose of all (other) user interface structures by releasing its reference to the <tt>Ballot</tt>, the <tt>BallotParser</tt>, and the <tt>ViewManager</tt>. The machine then waits to be initialized by an administrator before it will enter another vote session.
</li></ul><h3 id="Driverclass">Driver class</h3>
<p>
TBD
</p>


</body>
</html>

